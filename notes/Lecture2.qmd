---
title: "Lecture 2"
execute:
  freeze: auto  # re-render only when source changes
format: 
    revealjs:
        theme: night
        incremental: true
        preview-links: auto
        chalkboard: true
engine: julia
julia:
  exeflags: ["--project=../PopGen25"]
---

# Lecture 2: Describing genetic diversity

## Genetic diversity writ large

Last week you learned how different evolutionary forces affect allele frequencies at a single site.

. . .

This week, we'll be discussing how we can measure genetic diversity and what those measurements can tell us.

. . .

We will look at a few statistics that measure genetic diversity, notably the SFS, $\pi$, $\theta_W$ and $H$.

. . .

Before that, we'll talk about why we even care.

## What is diversity good for?

*Evolution is the change in traits of populations over generations*

. . .

Change is impossible if variation does not exist.

. . .

Genetic variation allows for evolvability - without it populations are stuck.

. . .

*Most* variation might in fact be deleterious in any particular environment.

. . .

Conversely, if the environment changes - old variants are unlikely to meet all of its needs.

## Where does diversity come from?

Ultimately, all genetic diversity begins with mutation.

. . .

A key quantity in population genetics is $\theta$ - the neutral genetic diversity.

. . .

Under Wright-Fisher, $\theta = 4 N_e \mu$, where $N_e$ is the *effective* population size, and $\mu$ is the *neutral* mutation rate.

. . .

So, diversity should depend on both the population size and mutation rates. Does it?

## Measuring diversity at a site

Before we think about what's happening across the genome, we can start by asking what is happening at an individual locus.

::: callout-tip
## Recall

We will refer to the allele frequency of the *alternate* allele at site $j$ as $p$.
:::

What are some ways we can ask how diverse a population is at a site?

## Expected Heterozygosity ( *H* )

One of the simplest metrics is to ask how frequently we see individuals who are heterozygous.

. . .

Let's start by generalizing to any number of alleles.

. . .

$$
H_j = 1 - \sum_{i=1}^{k}{p_i^2}
$$

Where $p_i$ is the frequency of the $i^{th}$ allele and there are a total of $k$ alleles.

. . .

If there are only two alleles:

$$1-p_a^2 -p_A^2 = 2p_a(1-p_a)$$

. . .

In practice - often not the case: why?

## Sample heterozygosity (*h*) {.smaller}

Another way to think about genetic diversity is to ask:

What is the probability that if you sample any two alleles in the population, they are different.

. . .

In an infinite population with a biallelic site, this is simply $2p(2-p)$

. . .

But populations are not infinite, and we also don't sample all possible individuals.

. . .

Instead, we calculate the expected *sample* heterozygosity, and account for number of alleles sampled ($n$):

$$
h_j=\frac{n}{n-1}\left(1-\sum_i^k{p_i^2}\right)
$$

## Heterozygosity across a region (π)

We can then zoom out and ask what the diversity is across a whole region. Say there are $L$ sites in your region, then the total *polymorphism* is given by:

$$
\pi = \sum_{j=1}^{L}{h_j}
$$

. . .

The more common definition you'll see is the *per site* *polymorphism/heterozygosity*, given as:

$$
\pi =  \frac{1}{L}\sum_{j=1}^{L}{h_j}
$$

Note, often the two will be labeled as $\pi$, but per-site is more common.

## Let's check some intuition

Here, we'll use the example data from Hahn's textbook:

```{julia}
fake_data = 
["T" "T" "A" "C" "A" "A" "T" "C" "C" "G" "A" "T" "C" "G" "T";
 "-" "-" "A" "C" "G" "A" "T" "G" "C" "G" "C" "T" "C" "G" "T";
 "T" "C" "A" "C" "A" "A" "T" "G" "C" "G" "A" "T" "G" "G" "A";
 "T" "T" "A" "C" "G" "A" "T" "G" "-" "-" "C" "T" "C" "G" "T"]
[join(i) for i in eachrow(fake_data)]
```

Each row is an individual, each column is a site. Notice how some sites have missing data "-".

. . .

What is the heterozygosity at the third site?

. . .

How can we account for missing data in calculating heterozygosity?

## Code examples

```{julia}
#| echo: true
using StatsBase

function sample_h(alleles)
    obs_alleles=collect(skipmissing(alleles)) #Genotypes might be missing - we skip those.
    n=length(obs_alleles)
    freqs = values(countmap(obs_alleles)) ./ n #Get allele frequencies for each allele
    return( n/(n-1)*(1-sum(freqs .^ 2))) #Return the expected sample h
end

function sample_π(genotype_matrix)
    return(sum([sample_h(genotype_matrix[:,x]) for x in 1:size(genotype_matrix)[2]])) #Sum of h over all sites
end

sample_π(replace(fake_data,"-"=>missing))
```

## Not the only heterozygosity

$\pi$ is a commonly used estimator for genetic diversity, but it has some issues. The biggest is that when true diversity is high, variance in *sample* diversity is also really high. That is, it's hard to get an accurate estimate.

```{julia}
using Plots, LaTeXStrings, Measures
function var_pi(θ,n)
    (n+1)/(3*(n-1))*θ+2(n^2+n+3)/(9*n*(n-1))*θ^2
end
ns=range(10,1000,length=50)
thetas = [var_pi.(theta,ns) for theta in [0.1,1,5,10]]
plot(ns,thetas,xlabel="n",ylabel=L"Var(\pi)",label=["0.1" "1" "5" "10"],margins=5mm)
```

## Alternatives to $\pi$ : $\theta_W$

One common alternative is to use Watterson's Theta. The idea is that we can simply look at the *number* of segregating sites $S$ (sites with at least one variant). Because as we sample more individuals, we are more likely to sample a new allele, there is a correction factor:

$$
\theta_W = \frac{S}{\sum_{i=1}^{n-1}{1/i}}
$$

```{julia}
#| echo: true
function wat_theta(gm)
    S = sum([is_segregating(i) for i in eachcol(gm)])
    a = sum([1/i for i in 1:size(gm)[1]])
    return(S/a)
end
```

## $\theta_W$ - lower variance with greater sampling

Unlike $\pi$, $\theta_W$ shows a nice decrease in sample variance with more samples.

```{julia}
function theta_var(n,theta)
    vars =sum([theta/i for i in 1:(n-1)])+sum([theta^2/(i^2) for i in 1:(n-1)])
    a = sum([1/i for i in 1:(n-1)])
    return(vars/(a^2))
end

thetas_w = [theta_var.(ns,i) for i in [0.1,1,5,10]]
plot(ns,thetas_w,xlabel="n",ylabel=L"Var(\theta_W)",label=["0.1" "1" "5" "10"],margins=5mm)
```

## Why is $\theta_W$ not the standard?

Accuracy from sample size is not the only potential issue:

. . .

$\theta_W$ is not robust to other sources of errors:

-   missing data

-   sequencing error

-   uneven sampling

. . .

In practice, it's often good to be able to look at multiple different estimators, and make informed conclusions about the data from them.

## Single data point for whole genome?

$\theta$, $\pi$, $h$ and similar are *summary statistics* - they reduce potentially huge amounts of data into a single number. That *can* be useful, but sometimes it's better to look at a denser view of the data. Let's make a larger/more complicated data-set.

```{julia}
include("../src/useful_code.jl")
ancestral=fake_alignment(1,200)
geno_matrix = fake_alignment_biallelic(ancestral,30;gaps=0.01)
[join(replace(i,missing=>"-")) for i in eachrow(geno_matrix)]
```

## Longer alignment - more information

One good way to represent a whole region is to summarize the allele frequencies at each site. This is called the *Site Frequency Spectrum*, or (*Allele Frequency Spectrum*). In our complicated alignment, it helps us see the frequency of different alleles.

## SFS example:

```{julia}
#| echo: false
function SFS(gm) 
    return([minimum(values(countmap(i)))/length(i) for i in eachcol(gm)]); 
end

histogram(SFS(only_segregating(geno_matrix)),legend=false,xlabel="Minor Allele Frequency",ylabel="Count",margins=5mm,bins=30)
```

## Allele *polarity*: ancestral state

When you don't know what the ancestral allele is, you generally examine the *minor* allele frequency (whichever is rarer.

. . .

This results in a *folded* SFS.

. . .

But, if you have an outgroup/ancestral data, you can instead use the full SFS.

## What do you do with the SFS

One of the uses of the SFS is, ironically, to calculate summary statistics.

. . .

Some, like $\theta_H$ estimate the genetic diversity.

. . .

Others, like Tajima's D (which we'll talk about more later) let you estimate the influence of demography on the population.

## 

## How is variation distributed among individuals?

We can now say something about how genetic variation is sumarised across a population. *But* this gives us very little information about how the variation is distributed within each individual.

For instance, if overall $\pi$ is high - does that mean that every individual is likely to *be* heterozygous?

## Summarizing complex data: PCA {.smaller}

Principal component analysis (PCA) is an approach to take complex, highly dimensional data (like the genotypes of a bunch of individuals at very many sites), and reduce it to something simpler.

```{julia}
using MultivariateStats
x = randn(1000)
y = x+randn(1000)

pca_test_plot=scatter(x,y,leg=false)

```

## PC1 identifies the axis of highest variability

```{julia}
pca_m = fit(PCA,transpose(hcat(x,y)))
plot!(pca_test_plot,i->i*scaled_loadings(pca_m)[1,1],-4,4)
```

## Each PC explains the next most variation {.smaller}

When data fits PCA assumptions, each subsequent PC explains the next most variance.

. . .

These assumptions are met for most genomic data.

```{julia}
plot!(pca_test_plot,i->i*(1/scaled_loadings(pca_m)[1,2]))
```

## Works in genomic data too!

Here's our toy sequence data along the first two PCs.

```{julia}
gm_PCA = fit(PCA,geno_mat_to_Int(geno_matrix))
scatter(gm_PCA.proj[:,1],gm_PCA.proj[:,2])
```

## Is PCA always worth it?

How do you know how many PCs are "enough" to describe your data?

. . .

PCA significance can be evaluated using the *broken stick model*.

. . .

If you choose *n* random break points of a stick of length 1, then the size of these segments follows a typical distribution:

```{julia}
bar(reverse([broken_stick_dist(i,10) for i in 1:10]),legend=false,xlabel="PC",ylabel="Variance explained",margins=5mm,size=(800,500))
```

## How does that compare to our toy sequence data?

```{julia}
p1 = scree(pca_m)
p2 = scree(gm_PCA)
```